#pragma once
/**
 * @file fix_handler.h
 * @brief FIX protocol handler built on the Fix8 engine.
 *
 * Provides a high-level C++ API for establishing FIX sessions,
 * sending orders (NewOrderSingle), and receiving execution reports.
 * Designed to be exposed to Python via pybind11.
 */

#include <string>
#include <functional>
#include <vector>
#include <mutex>
#include <atomic>
#include <thread>
#include <queue>
#include <memory>
#include <iostream>

// ---------------------------------------------------------------------------
// Forward declarations – the real Fix8 types come from the generated headers
// produced by `f8c`.  When Fix8 is not installed we fall back to a lightweight
// stub so the rest of the project can still compile and run unit tests.
// ---------------------------------------------------------------------------
#ifdef HAS_FIX8
#   include <fix8/f8includes.hpp>
#   include "AM_types.hpp"   // generated by f8c from schema.xml
#   include "AM_classes.hpp"
#endif

namespace asset_mgr {

// ── Structs exposed to Python ───────────────────────────────────────────────

/// Represents a single FIX order to be sent out.
struct FixOrder {
    std::string cl_ord_id;   // Client order ID
    std::string symbol;
    char        side;        // '1' = Buy, '2' = Sell
    char        ord_type;    // '1' = Market, '2' = Limit, '3' = Stop
    double      quantity;
    double      price;       // Only relevant for Limit / Stop
};

/// Represents an execution report received from the counterparty.
struct ExecReport {
    std::string order_id;
    std::string exec_id;
    char        exec_type;   // '0'=New, '1'=PartialFill, '2'=Fill, '4'=Cancel, '8'=Reject
    char        ord_status;
    std::string symbol;
    char        side;
    double      leaves_qty;
    double      cum_qty;
    double      avg_px;
    double      last_px;
    double      last_qty;
    std::string text;
};

// ── Configuration ───────────────────────────────────────────────────────────

struct FixConfig {
    std::string sender_comp_id  = "ASSETMGR";
    std::string target_comp_id  = "EXCHANGE";
    std::string host             = "127.0.0.1";
    int         port             = 9876;
    int         heartbeat_interval = 30;
};

// ── Callback type ───────────────────────────────────────────────────────────

using ExecReportCallback = std::function<void(const ExecReport&)>;

// ── FixHandler – main public API ────────────────────────────────────────────

class FixHandler {
public:
    explicit FixHandler(const FixConfig& cfg = {});
    ~FixHandler();

    // ── Lifecycle ───────────────────────────────────────────────────────────
    /** Start the FIX session (Logon). Returns true on success. */
    bool start();

    /** Gracefully stop the FIX session (Logout + disconnect). */
    void stop();

    /** Returns true if the session is currently logged on. */
    bool is_connected() const;

    // ── Trading ─────────────────────────────────────────────────────────────
    /** Send a NewOrderSingle.  Returns the ClOrdID used. */
    std::string send_order(const FixOrder& order);

    // ── Execution Reports ───────────────────────────────────────────────────
    /** Register a callback that fires on every incoming ExecutionReport. */
    void on_exec_report(ExecReportCallback cb);

    /** Drain the internal queue and return all reports received so far. */
    std::vector<ExecReport> poll_exec_reports();

    // ── Status ──────────────────────────────────────────────────────────────
    std::string get_status() const;

private:
    FixConfig config_;
    std::atomic<bool> connected_{false};
    std::atomic<bool> running_{false};

    mutable std::mutex          mu_;
    std::queue<ExecReport>      report_queue_;
    ExecReportCallback          callback_;

    std::unique_ptr<std::thread> session_thread_;

    // Internal helpers
    void session_loop();
    void handle_exec_report(const ExecReport& rpt);

#ifdef HAS_FIX8
    // Fix8 session objects (owned pointers)
    std::unique_ptr<FIX8::ClientSession<AM::MyMenu_session_client>> fix_session_;
#endif
};

} // namespace asset_mgr
